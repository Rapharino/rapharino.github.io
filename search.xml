<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Spring Cloud - Ribbon]]></title>
      <url>http://rapharino.com/coder/Spring-Cloud-Ribbon/</url>
      <content type="html"><![CDATA[<p>依然 是 依赖于 Srping-Ioc 和自动配置的方式,实现 客户端负载均衡器的初始化配置. 由于 代码量多,层次关联复杂.因此选择从核心类开始阅读<br><a id="more"></a></p>
<blockquote>
<p>N : Netflix 的设计的类结构</p>
<p>SN : Spring 集成 Netflix 设计的类结构</p>
<p>S: Spring 设计的类结构</p>
</blockquote>
<p>S-  LoadBalancerClient :负载均衡器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancerClient</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据 serviceId 获取 ServiceInstance</span></div><div class="line">	<span class="function">ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span></span>;</div><div class="line">  	<span class="comment">// 执行LoadBalancerRequest</span></div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">    <span class="comment">// 根据ServiceInstance,原始 URI,拼接出 目标URI</span></div><div class="line">	<span class="function">URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SN- RibbonLoadBalancerClient : 基于 Ribbon实现的LoadBalancerClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">      	<span class="comment">// 根据 serviceId 获取 ILoadBalancer</span></div><div class="line">		ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</div><div class="line">      	<span class="comment">// 获取 Server</span></div><div class="line">		Server server = getServer(loadBalancer);</div><div class="line">		<span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</div><div class="line">		&#125;</div><div class="line">      	<span class="comment">// 重新包装为RibbonServer</span></div><div class="line">		RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server,</div><div class="line">				serviceId), serverIntrospector(serviceId).getMetadata(server));</div><div class="line">		<span class="comment">// 获取RibbonLoadBalancerContext</span></div><div class="line">		RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</div><div class="line">				.getLoadBalancerContext(serviceId);</div><div class="line">      	<span class="comment">//状态记录</span></div><div class="line">		RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">          	<span class="comment">// 执行请求</span></div><div class="line">			T returnVal = request.apply(ribbonServer);</div><div class="line">			<span class="comment">// 状态更新</span></div><div class="line">			statsRecorder.recordStats(returnVal);</div><div class="line">			<span class="keyword">return</span> returnVal;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// catch IOException and rethrow so RestTemplate behaves correctly</span></div><div class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="comment">// 状态更新</span></div><div class="line">			statsRecorder.recordStats(ex);</div><div class="line">			<span class="keyword">throw</span> ex;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">          	<span class="comment">// 状态更新</span></div><div class="line">			statsRecorder.recordStats(ex);</div><div class="line">			ReflectionUtils.rethrowRuntimeException(ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>​    可以观察到, 核心的负载均衡是由 ILoadBalancer实现的.通过SpringClientFactory 获取/创建 ILoadBalancer实现实例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">(String serviceId)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SN-SpringClientFactory:</p>
<p>用以 创建 Ribbon 的 负载均衡相关实例. 并 为每个”客户端名称” 创建一个 Spring ApplicationContext per,并从中提取需要的注入对象.(但它们公用一个父容器,可以拿到父容器中的 Bean 实例的引用).而 Spring 通过RibbonClientConfiguration创建 并使用了 ILoadBalancer的一个实现,名为ZoneAwareLoadBalancer.</p>
<p>到这里.差不多可以看出整体雏形了:</p>
<p>Spring Cloud  创建并注册 RibbonLoadBalancerClient. 在execute方法中, 委托给  Ribbon 的 ILoadBalancer获取 Server, 以实现负载均衡. 默认大家了解 Spring  RestTemplate(封装了 HTTP 相关方法的模板类), 在ClientHttpRequestExecution调用的过程中, 将被ClientHttpRequestInterceptor 实现拦截功能.在LoadBalancerAutoConfiguration部分,可以看到 配置注册了一个名为LoadBalancerInterceptor的ClientHttpRequestInterceptor.</p>
<p>S-LoadBalancerInterceptor: 实现了客户端负载均衡的拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></div><div class="line">      <span class="keyword">final</span> ClientHttpRequestExecution execution) <span class="keyword">throws</span> IOException &#123;</div><div class="line">   <span class="keyword">final</span> URI originalUri = request.getURI();</div><div class="line">   String serviceName = originalUri.getHost();</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是所有的<code>@LoadBalanced</code>注解的<code>RestTemplate</code>都会被拦截进入loadBalancer(RibbonLoadBalancerClient)并进行相应的执行.然后我们可以进行下一步了.</p>
<p>S-LoadBalancerRequest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancerRequest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">apply</span><span class="params">(ServiceInstance instance)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最新版LoadBalancerRequest而它是由LoadBalancerRequestFactory生成.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="title">createRequest</span><span class="params">(<span class="keyword">final</span> HttpRequest request,</span></span></div><div class="line">      <span class="keyword">final</span> <span class="keyword">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution) &#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerRequest&lt;ClientHttpResponse&gt;() &#123;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">apply</span><span class="params">(<span class="keyword">final</span> ServiceInstance instance)</span></span></div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">         <span class="comment">// HttpRequest包转</span></div><div class="line">         HttpRequest serviceRequest = <span class="keyword">new</span> ServiceRequestWrapper(request, instance, loadBalancer);</div><div class="line">         <span class="keyword">if</span> (transformers != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (LoadBalancerRequestTransformer transformer : transformers) &#123;</div><div class="line">              <span class="comment">//</span></div><div class="line">               serviceRequest = transformer.transformRequest(serviceRequest, instance);</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> execution.execute(serviceRequest, body);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是如此 将 RestTemplate 变为支持负载均衡的RestTemplate.</p>
<p>Spring集成 Ribbon 的部分已经介绍好了.下面继续深入了解下 N- ILoadBalancer 负载均衡器.(好累啊!!!.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILoadBalancer</span> </span>&#123;</div><div class="line">   <span class="comment">// 添加服务</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span></span>;</div><div class="line">   <span class="comment">// 选择服务</span></div><div class="line">   <span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span></span>;</div><div class="line">   <span class="comment">// 标记为关闭的服务</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markServerDown</span><span class="params">(Server server)</span></span>;</div><div class="line">   <span class="comment">// 获取所有服务</span></div><div class="line">   <span class="meta">@Deprecated</span></div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getServerList</span><span class="params">(<span class="keyword">boolean</span> availableOnly)</span></span>;</div><div class="line">   <span class="comment">// 获取所有可用服务</span></div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getReachableServers</span><span class="params">()</span></span>;</div><div class="line">   <span class="comment">// 获取所有服务</span></div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要介绍下几个子类</p>
<p>AbstractLoadBalancer 作为ILoadBalancer的抽象.定义了 服务分类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalancer</span> <span class="keyword">implements</span> <span class="title">ILoadBalancer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ServerGroup&#123;</div><div class="line">        ALL,</div><div class="line">        STATUS_UP,</div><div class="line">        STATUS_NOT_UP</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> chooseServer(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Server&gt; <span class="title">getServerList</span><span class="params">(ServerGroup serverGroup)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> LoadBalancerStats <span class="title">getLoadBalancerStats</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BaseLoadBalancer 作为基础类.主要功能有.</p>
<ol>
<li><p>定义了 IRule 变量.实现 服务选择算法.</p>
<ol>
<li>RandomRule 实现了随机选择算法</li>
<li>RoundRobinRule:实现了线性轮询算法</li>
<li>RetryRule:实现了重试选择的算法</li>
<li>WeightedResponseTimeRule:实现了更具服务状态,进行权重分析选择的算法.</li>
<li>…..还有很多</li>
</ol>
</li>
<li><p>定义了 IPingStrategy变量.  实现 Ping的策略.SerialPingStrategy为默认实现,线性顺序 Ping 操作.</p>
</li>
<li><p>定义了 IPing 变量.实现 服务是否活跃的判断.主要有:</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwgy1feuhjrtmb6j30f604t3zl.jpg" alt="F2EFE845-6BA2-4679-A6A5-5D84C84DC6FD"></p>
</li>
<li><p>维护了 服务列表</p>
</li>
</ol>
<p>DynamicServerListLoadBalancer.主要提供 服务状态动态更新的功能.</p>
<ol>
<li><p>ServerList 获取服务:</p>
<p>DiscoveryEnabledNIWSServerList 就实现了通过 EurekaClient 对服务列表的获取. 源码不写了.有兴趣大家可以自己读</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>ServerListUpdater 控制当前服务列表的更新策略.<ol>
<li>PollingServerListUpdater 轮询方式 更新.</li>
<li>DynamicServerListLoadBalancer: 客户端维护服务状态,并通过 控制状态改变事件的发布,实现 服务列表更新.</li>
</ol>
</li>
</ol>
<p>ZoneAwareLoadBalancer: 作为 DynamicServerListLoadBalancer的扩展,实现了关于 Zone 的概念,提高可用性.</p>
<p>参考资料<br><a href="http://blog.didispace.com/springcloud-sourcecode-ribbon/" target="_blank" rel="external">http://blog.didispace.com/springcloud-sourcecode-ribbon/</a> (感谢 DD)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IOC And Spring IOC]]></title>
      <url>http://rapharino.com/coder/IOC-And-Spring-IOC/</url>
      <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote>
<p>从基本概念出发,由浅入深的了解 IOC 和 Spring IOC.</p>
</blockquote>
<a id="more"></a>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="Don-t-call-us-we-will-call-you"><a href="#Don-t-call-us-we-will-call-you" class="headerlink" title="Don`t call us,we will call you"></a>Don`t call us,we will call you</h3><p>好莱坞原则.中文大意为 别来调用我,我来调用你. 恰如其分的说明了 IOC(Inversion of Controll) 的本质. 举个通俗的例子,人们想喝酒, 通常需要自己去选择品种,去取并装杯.但如果是去酒吧,你只需要和柜台服务人员,描述你想喝什么,甚至是一个眼神,就会得到你想喝的酒.这就是控制反转.将 对象的控制权,转移至外部容器,实现与复杂对象的解耦.从主动的 “拉” (创建对象),转为了 “推”(依赖注入).</p>
<p>依赖注入DI(Dependency Injection) 方式</p>
<ul>
<li>构造注入:实例构造方法中,选择并注入所需依赖对象.</li>
<li>setter 注入:依赖对象对应的setter方法中,选择并注入所需依赖对象.</li>
<li>接口注入:易用性和扩展性较差.逐渐淘汰.</li>
</ul>
<h3 id="IOC-Service-Provider"><a href="#IOC-Service-Provider" class="headerlink" title="IOC Service Provider"></a>IOC Service Provider</h3><p>作为一个抽象角色,担当IOC场景下的核心职责,主要包括:</p>
<ul>
<li>对象的构建管理</li>
<li>对象的依赖绑定</li>
</ul>
<p>主流产品包括有 Spring,Google Guice 等, 对于对象的构建管理和依赖绑定主要为三种方式</p>
<ul>
<li>直接编码</li>
<li>配置文件</li>
<li>元数据</li>
</ul>
<h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><h3 id="Spring-IOC-Service-Provider"><a href="#Spring-IOC-Service-Provider" class="headerlink" title="Spring - IOC Service Provider"></a>Spring - IOC Service Provider</h3><p>Spring 的 IOC 是 IOC Service Provider 的一个实现,并且是一个包含了 AOP,对象查找等高级特性的 一个IOC超集.因此被称为 Spring 的 IOC Container (容器),其关系如下:</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fei4g2c7l7j30sq0lqdiz.jpg" alt=""></p>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>Spring IOC容器的核心接口, 主要的UML如下</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fekbx9sbw8j30kx0dkab7.jpg" alt=""></p>
<ol>
<li><p>BeanFactory: </p>
<p>提供了完整的 IOC 服务支持.典型的工厂类,负责对象(POJO)的创建(注册),依赖绑定,查找 等功能.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据名称获取 Bean</span></div><div class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">    <span class="comment">// 根据类型获取 Bean</span></div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">	   <span class="comment">// 是否为单实例  </span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line">    <span class="comment">// 是否为多实例</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line">    <span class="comment">// 根据实例的名字获取类型 </span></div><div class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</div><div class="line">    <span class="comment">// 根据名称获取别名组</span></div><div class="line">    String[] getAliases(String name);</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>AutowireCapableBeanFactory：</p>
<p>在BeanFactory基础上实现对已存在实例的管理,提供自动装配(AutoWire,是 Srping 依赖注入的 一种方式.以约定规则进行依赖关系的绑定)等功能性方法.实际开发中较少，像ApplicationContext就未实现该接口。主要用于动态加入 Bean并自动装配 至容器中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 部分核心代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> AUTOWIRE_NO = <span class="number">0</span>;<span class="comment">//不使用自动装配 </span></div><div class="line">    <span class="keyword">int</span> AUTOWIRE_BY_NAME = <span class="number">1</span>;<span class="comment">//通过名称自动装配 </span></div><div class="line">    <span class="keyword">int</span> AUTOWIRE_BY_TYPE = <span class="number">2</span>;<span class="comment">//通过类型自动装配  </span></div><div class="line">    <span class="keyword">int</span> AUTOWIRE_CONSTRUCTOR = <span class="number">3</span>;<span class="comment">//构造器装配 </span></div><div class="line">  </div><div class="line">    <span class="comment">// 根据给定的类型和指定的装配策略，创建一个新的Bean实例</span></div><div class="line">    <span class="function">Object <span class="title">createBean</span><span class="params">(Class&lt;?&gt; beanClass, <span class="keyword">int</span> autowireMode, <span class="keyword">boolean</span> dependencyCheck)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">    <span class="comment">//为已存在Bean 自动装配</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">autowireBeanProperties</span><span class="params">(Object existingBean, <span class="keyword">int</span> autowireMode, <span class="keyword">boolean</span> dependencyCheck)</span> <span class="keyword">throws</span> BeansException</span>; </div><div class="line">    <span class="comment">//为指定类和名称 自动装配</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyBeanPropertyValues</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">    <span class="comment">//初始化一个Bean</span></div><div class="line">    <span class="function">Object <span class="title">initializeBean</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">    <span class="comment">//初始化之前执行BeanPostProcessors</span></div><div class="line">    <span class="function">Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">    <span class="comment">//初始化之后执行BeanPostProcessors</span></div><div class="line">    <span class="function">Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</div><div class="line">    <span class="comment">//销毁一个Bean</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(Object existingBean)</span></span>;</div><div class="line">    <span class="comment">//分解指定的依赖</span></div><div class="line">    <span class="function">Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, String beanName,</span></span></div><div class="line">            Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter) <span class="keyword">throws</span> BeansException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>HierarchicalBeanFactory：</p>
<p>提供父容器的访问支持.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line"> <span class="comment">// 获取父的BeanFactory</span></div><div class="line">	<span class="function">BeanFactory <span class="title">getParentBeanFactory</span><span class="params">()</span></span>;</div><div class="line">	<span class="comment">// 在本地容器查找是否存在指定名称的 Bean.</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsLocalBean</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>ListableBeanFactory：</p>
<p>主要是 提供了批量获取Bean的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</div><div class="line">	   <span class="comment">// 根据类型查找 Bean 的名称数组</span></div><div class="line">    String[] getBeanNamesForType(Class&lt;?&gt; type); </div><div class="line">	   <span class="comment">// 根据类型查找 Bean 的Map</span></div><div class="line">    &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException</span>; </div><div class="line">    <span class="comment">//根据注解查找相关Bean 名称数组</span></div><div class="line">    String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType); </div><div class="line">    <span class="comment">//根据注解查找相关Bean的 Map</span></div><div class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getBeansWithAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> <span class="keyword">throws</span> BeansException</span>; </div><div class="line">    <span class="comment">//查找一个Bean上的注解</span></div><div class="line">    &lt;A extends Annotation&gt; <span class="function">A <span class="title">findAnnotationOnBean</span><span class="params">(String beanName, Class&lt;A&gt; annotationType)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h3><p>该类的作用主要是向注册表中注册 BeanDefinition 实例，完成 注册的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 往注册表中注册一个新的 BeanDefinition 实例 </span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span><span class="keyword">throws</span> BeanDefinitionStoreException</span>;</div><div class="line">    <span class="comment">// 移除注册表中已注册的 BeanDefinition 实例</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line">    <span class="comment">// 从注册中取得指定的 BeanDefinition 实例</span></div><div class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line">    <span class="comment">// 判断 BeanDefinition 实例是否在注册表中（是否注册）</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</div><div class="line">    <span class="comment">// 取得注册表中所有 BeanDefinition 实例的 beanName（标识）</span></div><div class="line">    String[] getBeanDefinitionNames();</div><div class="line">    <span class="comment">// 返回注册表中 BeanDefinition 实例的数量</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// beanName（标识）是否被占用</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>用于保存容器中受管对象的所有必要信息.包括类型,构造参数,属性参数,以及 Bean生命周期相关参数 等等.往往由BeanDefinitionReader 来完成BeanDefinition的解析和创建.</p>
<h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h3><p>作为Spring IOC 的鼻祖,一个真正可用的一个 BeanFactory的是一个实现.(现在应用较少). 继承了BeanFactory,BeanDefinitionRegistry. 举个例子我们可以大致了解雏形了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">    <span class="comment">// 创建 BeanFactory</span></div><div class="line">    DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory();   </div><div class="line">    <span class="comment">// 创建 BeanDefinition</span></div><div class="line">    AbstractBeanDefinition userDefinition = <span class="keyword">new</span> RootBeanDefinition(User.class,<span class="keyword">true</span>);   </div><div class="line">    AbstractBeanDefinition carDefinition = <span class="keyword">new</span> RootBeanDefinition(Car.class,<span class="keyword">true</span>);   </div><div class="line">    <span class="comment">// 注册到 BeanFactory</span></div><div class="line">    beanRegistry.registerBeanDefinition(<span class="string">"user"</span>, userDefinition);   </div><div class="line">    beanRegistry.registerBeanDefinition(<span class="string">"car"</span>, carDefinition);</div><div class="line">    <span class="comment">// 1.通过构造注入 方式</span></div><div class="line">    ConstructorArgumentValues argValues = <span class="keyword">new</span> ConstructorArgumentValues();   </div><div class="line">    argValues.addIndexedArgumentValue(<span class="number">0</span>, carDefinition); </div><div class="line">    userDefinition.setConstructorArgumentValues(argValues);</div><div class="line">    <span class="comment">// 2. 或者通过setter方法注入方式   </span></div><div class="line">    MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues();   </div><div class="line">    propertyValues.addPropertyValue(<span class="keyword">new</span> ropertyValue(<span class="string">"car"</span>,carDefinition)); </div><div class="line">    userDefinition.setPropertyValues(propertyValues);</div><div class="line">  </div><div class="line">  	<span class="comment">// 完成构建,应用</span></div><div class="line">    beanRegistry.getBean(<span class="string">"user"</span>).getCar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出来,BeanDefinition 是整个 容器的核心.描述了对象创建和依赖绑定的 必要信息.</p>
<p>原生硬编码的方式,需要手动定义BeanDefinition,并且需要设置依赖注入关系.编码成本较高. 而上文我们提到 IOS Service Provide 包活 直接编码,配置文件,元数据 等方式实现. Spring BeanDefinitionReader 接口就是提供了配置文件方式构建容器.截至 Spring 4.x ,实现类有 GroovyBeanDefinitionReader,PropertiesBeanDefinitionReader,XmlBeanDefinitionReader.以 XML 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">  <span class="comment">// 创建 BeanFactory</span></div><div class="line">  DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory(); </div><div class="line">  <span class="comment">// 创建 XmlBeanDefinitionReader</span></div><div class="line">  XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(registry);  </div><div class="line">  <span class="comment">// 配置资源解析</span></div><div class="line">  reader.loadBeanDefinitions(<span class="string">"classpath:spring.xml"</span>);  </div><div class="line">  <span class="comment">// 获取 Bean</span></div><div class="line">  User user = (User)container.getBean(<span class="string">"user"</span>);  </div><div class="line">  user.getCar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot Induction]]></title>
      <url>http://rapharino.com/coder/Spring-Boot-Induction/</url>
      <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote>
<p>Spring Boot简化了基于Spring的应用开发，尝试封装 Spring 可怕繁杂的配置,以尽量少的配置创建一个独立的,产品级别的Spring应用。 Spring Boot使得Spring应用变的更轻量化,自动化,并为Spring平台及第三方库提供开箱即用的配置.Spring Boot 并未引入任何形式的代码生成技术,而是利用了 Spring4 的特性和项目构建实践 的优秀集成应用框架.因此本质上还是 Spring.</p>
</blockquote>
<a id="more"></a>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>为所有Spring开发提供一个从根本上更快，且随处可得的入门体验。</li>
<li>开箱即用，但通过不采用默认设置可以快速摆脱这种方式。</li>
<li>提供一系列大型项目常用的非功能性特征，比如：内嵌服务器，安全，指标，健康检测，外部化配置。</li>
<li>没有冗余代码生成，也不需要XML配置。</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>自动配置: 针对常用的功能,提供默认配置.以满足最基础功能.</li>
<li>起步依赖: 提供大量的扩展库, 实现各个功能.</li>
<li>命令行界面: 可选特性,无需构建项目, 实现 SpringBoot的动态编译和运行.</li>
<li>Actuator : 提供基础监控服务,提供运行时的检视应用内部情况的能力.包括<ul>
<li>上下文中的 Bean</li>
<li>自动配置策略(条件化配置)</li>
<li>环境变量,系统属性,配置属性,命令行参数 等.</li>
<li>线程状态</li>
<li>HTTP 调用情况记录</li>
<li>内存用量,垃圾回收,请求等相关指标.</li>
</ul>
</li>
</ul>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>Spring Boot 极力的贴合 约定优于配置的设计范式.下面是一个 Demo,以最少的代码,实现一个 Web Service.</p>
<h4 id="maven-构建项目"><a href="#maven-构建项目" class="headerlink" title="maven 构建项目"></a>maven 构建项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- boot parent --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">     	<span class="comment">&lt;!-- boot starter --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- web starter --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</div><div class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SpringApplication.run(App.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 如果使用浏览器打开<a href="http://localhost:8080/" target="_blank" rel="external">localhost:8080</a>，你应该可以看到如下输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>rp-core 中的 SpringApplication 的实现方式和 SpringBoot 类似,主要借鉴其 自动配置,ApplicationContext生命周期管理功能.</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fd68s6upl5j310i19wq5x.jpg" alt=""></p>
<ol>
<li><p>xml 或者 java code  实现对象构建和依赖绑定的描述信息.</p>
</li>
<li><p>创建AnnotationConfigApplicationContext(或者AnnotationConfigEmbeddedWebApplicationContext)  (上图错误.)</p>
</li>
<li><p><code>SpringFactoriesLoader.loadFactoryNames()</code>读取了ClassPath下面的<code>META-INF/spring.factories</code>文件.其中主要包括ApplicationContextInitializer,ApplicationListener,和@Configuration 其相关实现类(注解类).</p>
</li>
<li><p>为 ApplicationContext 注册ApplicationContextInitializer.ApplicationListener.(原生 Spring 提供的扩展)</p>
</li>
<li><p>启动 自动配置流程</p>
<ol>
<li><p>SpringBootApplication注解中带有EnableAutoConfiguration注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@AutoConfigurationPackage</span></div><div class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</div><div class="line"></div><div class="line">	String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Exclude specific auto-configuration classes such that they will never be applied.</div><div class="line">	 * <span class="doctag">@return</span> the classes to exclude</div><div class="line">	 */</div><div class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Exclude specific auto-configuration class names such that they will never be</div><div class="line">	 * applied.</div><div class="line">	 * <span class="doctag">@return</span> the class names to exclude</div><div class="line">	 * <span class="doctag">@since</span> 1.3.0</div><div class="line">	 */</div><div class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>EnableAutoConfiguration 为容器注册了一个EnableAutoConfigurationImportSelector对象.它则是自动配置的核心类.</p>
</li>
<li><p>EnableAutoConfigurationImportSelector实现了ImportSelector的selectImports方法:</p>
<ol>
<li><p><code>SpringFactoriesLoader.loadFactoryNames()</code>获取配置相关的元数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Auto Configure</div><div class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</div><div class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</div><div class="line">......</div><div class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>必要的处理.如去重,排序,条件依赖.</p>
</li>
<li><p>返回交由容器注册相关实例对象.</p>
</li>
</ol>
</li>
<li><p>容器初始化完成.(额外会提供点周边服务,如 CommandLineRunner)</p>
</li>
</ol>
</li>
</ol>
<h3 id="外置配置"><a href="#外置配置" class="headerlink" title="外置配置"></a>外置配置</h3><p>SpringBoot 兼顾 Spring的强大功能,并且提供极强的扩展性.在 SpringBoot及其周边项目有大量的 Starter模块,实现各个功能.如 spring-boot-starter-web,spring-boot-starter-jmx,spring-boot-starter-mybatis.他们有自己的默认配置,也可以通过 Spring 的属性 API 进行自定义.</p>
<h4 id="属性API"><a href="#属性API" class="headerlink" title="属性API"></a>属性API</h4><ul>
<li><code>PropertySource</code>：属性源，key-value属性对抽象，比如用于配置数据</li>
<li><code>PropertyResolver</code>：属性解析器，用于解析相应key的value</li>
<li><code>Environment</code>：环境，本身是一个PropertyResolver，但是提供了<code>Profile</code>特性，即可以根据环境得到相应数据（即激活不同的Profile，可以得到不同的属性数据，比如用于多环境场景的配置（正式机、测试机、开发机DataSource配置））</li>
<li><code>Profile</code>：剖面，只有激活的剖面的组件/配置才会注册到Spring容器，类似于maven中profile</li>
</ul>
<h4 id="配置读取顺序"><a href="#配置读取顺序" class="headerlink" title="配置读取顺序"></a>配置读取顺序</h4><p><code>SpringBoot</code> 配置使用一个特别的顺序进行合理的配置和覆盖.允许开发者通过配置服务,静态文件,环境变量,命令行参数,注解类等,用以外化配置.覆盖顺序如下:</p>
<ol>
<li>命令行参数</li>
<li>来自于 java:comp/env 的 JNDI 属性</li>
<li>操作系统环境变量</li>
<li>在打包的 jar 外的配置文件(包括 propertis,yaml,profile变量.)</li>
<li>在打包的 jar 内的配置文件(包括 propertis,yaml,profile变量.)</li>
<li>@Configuration 类的@PropertySource 注解</li>
<li>应用框架默认配置</li>
</ol>
<p>application.properties和application.yml文件能放在以下四个位置。亦拥有覆盖顺序(高 - 低)</p>
<ul>
<li>外置，在相对于应用程序运行目录的/config子目录里。</li>
<li>外置，在应用程序运行的目录里。</li>
<li>内置，在config包内。</li>
<li>内置，在Classpath根目录。</li>
</ul>
<p>每个模块都有自己的配置.在此不再赘述.</p>
<h3 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h3><p>Actuator端点,实现应用内部信息监控检测.实际开发和生产(必要控制)场景下,它的作用必不可少.</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNbRwgy1fem2c3sce6j30z505jac7.jpg" alt="AD3362AA-6045-4C59-A763-CAF849464AF1"></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNbRwgy1fem2cg9qmij30yx09x790.jpg" alt="9A86C781-0629-4D8D-90B4-B5B007FDB514"></p>
<p>(除了提供 rest service.还提供了 remote shell ,和 mbean 方式,目的类似).</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringCloud 第一弹 - Spring-cloud-config]]></title>
      <url>http://rapharino.com/coder/SpringCloud-1/</url>
      <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><blockquote>
<p>在一个高可用的微服务架构中,配置中心 是一个不可或缺的服务,用以集中管理应用程序在 运行时 所需的外部配置.避免了分布式系统所造成的配置无序,繁杂等问题.可配合版本管理系统,实现配置参数的拉取(推送).典型应用如<code>Zookeeper</code>,<code>Consul</code>,百度的<code>DisConf</code>,淘宝的<code>Diamond</code>,<code>Spring Cloud Config</code><br><a id="more"></a></p>
<h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2></blockquote>
<p>之所以选择 <code>Spring Cloud Config</code>:</p>
<ul>
<li>社区活跃,更新频繁.</li>
<li>无痕衔接 Spring 属性管理 API</li>
<li>极高的定制化能力.</li>
<li>基于<code>SpringBoot</code>,天生的适合云服务的开发和部署.</li>
</ul>
<h2 id="Spring-属性管理："><a href="#Spring-属性管理：" class="headerlink" title="Spring 属性管理："></a>Spring 属性管理：</h2><p>其实是在 Spring3.1 就提供了新的属性管理API,功能强大,设计极其具有美感.</p>
<h3 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h3><ul>
<li><code>PropertySource</code>：属性源，key-value属性对抽象，比如用于配置数据</li>
<li><code>PropertyResolver</code>：属性解析器，用于解析相应key的value</li>
<li><code>Environment</code>：环境，本身是一个PropertyResolver，但是提供了<code>Profile</code>特性，即可以根据环境得到相应数据（即激活不同的Profile，可以得到不同的属性数据，比如用于多环境场景的配置（正式机、测试机、开发机DataSource配置））</li>
<li><code>Profile</code>：剖面，只有激活的剖面的组件/配置才会注册到Spring容器.</li>
</ul>
<h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>推荐使用 Maven 作为项目构建工具.(<a href="http://rapharino.com/coder/Spring-Boot-Induction/">如若不了解 SpringBoot</a>)<br>目录如下:<br><img src="http://oextu0tw4.bkt.clouddn.com/14773239279405.jpg" alt=""></p>
<h3 id="Pom-文件"><a href="#Pom-文件" class="headerlink" title="Pom 文件"></a>Pom 文件</h3><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="创建Main-Class"><a href="#创建Main-Class" class="headerlink" title="创建Main-Class"></a>创建Main-Class</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@see</span> org.springframework.boot.autoconfigure.SpringBootApplication  Annotate SpringBoot Application</div><div class="line"> * <span class="doctag">@see</span> org.springframework.cloud.config.server.EnableConfigServer    Annotate ConfigServer Application</div><div class="line"> *</div><div class="line"> * Created by Rapharino on 2016/10/02.</div><div class="line"> */</div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableConfigServer</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Application.class);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ConfigurableApplicationContext configurableApplicationContext = SpringApplication</div><div class="line">                .run(Application.class, args);</div><div class="line">        Environment environment = configurableApplicationContext.getEnvironment();</div><div class="line"></div><div class="line">        LOGGER.info(<span class="string">"Server with active profiles:&#123;&#125; is running at http://&#123;&#125;:&#123;&#125;"</span>,environment.getActiveProfiles(),environment.getProperty(<span class="string">"server.address"</span>), environment.getProperty(<span class="string">"server.port"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="仓储配置"><a href="#仓储配置" class="headerlink" title="仓储配置"></a>仓储配置</h3><p>推荐使用 git 作为配置文件的版本管理.(支持文件系统, svn 服务)<br><img src="http://oextu0tw4.bkt.clouddn.com/14773243182721.jpg" alt=""></p>
<p>在 SpringCloud 家族中推荐,YAML 作为外部配置文件的声明语法.<br><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html?f=tt" target="_blank" rel="external">推荐阮一峰老师的关于 YAML 的简介</a></p>
<h4 id="配置读取顺序"><a href="#配置读取顺序" class="headerlink" title="配置读取顺序"></a>配置读取顺序</h4><p><code>SpringBoot</code> 配置使用一个特别的顺序进行合理的配置和覆盖.允许开发者通过配置服务,静态文件,环境变量,命令行参数,注解类等,用以外化配置.覆盖顺序如下:</p>
<ol>
<li>命令行参数</li>
<li>来自于 java:comp/env 的 JNDI 属性</li>
<li>操作系统环境变量</li>
<li>在打包的 jar 外的配置文件(包括 propertis,yaml,profile变量.)</li>
<li>在打包的 jar 内的配置文件(包括 propertis,yaml,profile变量.)</li>
<li>@Configuration 类的@PropertySource 注解</li>
<li>应用框架默认配置</li>
</ol>
<p>并且可通过新的 Api 进行配置的优雅注入.如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@Primary</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>代码由 <a href="https://github.com/Gexin-Team/cloud-in-action" target="_blank" rel="external">https://github.com/Gexin-Team/cloud-in-action</a> 托管. 出自 Gexin 团队.</p>
<h3 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h3><p><a href="http://docs.spring.io/spring-boot/docs/1.4.0.RELEASE/reference/html/" target="_blank" rel="external">http://docs.spring.io/spring-boot/docs/1.4.0.RELEASE/reference/html/</a><br><a href="http://cloud.spring.io/spring-cloud-static/spring-cloud-config/1.2.0.M1/" target="_blank" rel="external">http://cloud.spring.io/spring-cloud-static/spring-cloud-config/1.2.0.M1/</a><br><a href="https://segmentfault.com/a/1190000005029218" target="_blank" rel="external">https://segmentfault.com/a/1190000005029218</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[努力不成为曾经讨厌的人]]></title>
      <url>http://rapharino.com/lifer/%E5%8A%AA%E5%8A%9B%E4%B8%8D%E6%88%90%E4%B8%BA%E6%9B%BE%E7%BB%8F%E8%AE%A8%E5%8E%8C%E7%9A%84%E4%BA%BA/</url>
      <content type="html"><![CDATA[<p><img src="http://oextu0tw4.bkt.clouddn.com/2016-10-19-14768529565356.jpg" alt=""><br>想必 大多数人相对于锤子的产品和设计,更感兴趣的是老罗的相声.<br>这是锤子发布会 最悲哀和痛心的地方.<br>整场下来,老罗叹息声频出…<br>隐感到的 是心酸,妥协的无奈,还有强忍着 “极力迎合”的不屈…<br><a id="more"></a><br><img src="http://oextu0tw4.bkt.clouddn.com/2016-10-19-14768529489279.jpg" alt=""></p>
<blockquote>
<p>努力不成为自己曾讨厌过的人.<br>或者…尽量延迟这个时间的到来.<br>这是最大的妥协了.</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://rapharino.com/lifer/hello-world/</url>
      <content type="html"><![CDATA[<h2 id="难得此刻"><a href="#难得此刻" class="headerlink" title="难得此刻"></a>难得此刻</h2><blockquote>
<p>终于”停一停”了.<br>   想着开始 HelloWorld!</p>
</blockquote>
<h2 id="关于Rapharino"><a href="#关于Rapharino" class="headerlink" title="关于Rapharino"></a>关于Rapharino</h2><p>全名为 Raphael + Carino (意大利文+英文)<br>Raphael :意大利文发音,《圣经·旧约》中的四大天使其二，司琴天使。<br>Carino :一首轻音乐.<br><a id="more"></a><br><img src="http://oextu0tw4.bkt.clouddn.com/yl.png" alt="y"><br>至于”Redvlevet”,只是因为”撞名”了.<br>因此吸取教训,Rapharino有关的主要 社交平台,账户,邮箱,域名.都在今晚被我注册了.~.~</p>
<h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>关于博客的由来,这是个很严肃的答案.</p>
<ul>
<li>因为”Rapharino”.(50%)</li>
<li>为了社交和自我营销增值.(20%)</li>
<li>恐慌和发泄.(20%)</li>
<li>满足程序员天生的个人英雄主义和可敬的开源思想.(10%)</li>
</ul>
<p>心血来潮,熬夜8小时就完成了.坚持更新吧…(包括 一些技术,一些吐槽,一些所思所感.)</p>
<h2 id="关于建站"><a href="#关于建站" class="headerlink" title="关于建站"></a>关于建站</h2><p>git,gitpage,node,hexo,text…这是都是关键字,自行google吧.写的都很好,没必要重复了.不过建议配合 webstrom,mweb.多写点脚本.不然还是挺麻烦的.<br><strong><em> 或者给我留言,请我喝杯咖啡.免费为你搭建和维护.这个可以有吧?哈哈哈哈哈~~~ </em></strong><br><img src="http://oextu0tw4.bkt.clouddn.com/hh.jpg" alt="hh"></p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>http://rapharino.com/baidu_verify_6ArRBighOY.html</url>
      <content type="html"><![CDATA[6ArRBighOY]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分类]]></title>
      <url>http://rapharino.com/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[标签]]></title>
      <url>http://rapharino.com/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
